# The Metapattern

This document defines the canonical structure behind SYNTRIAD.

It does not argue for a theory, a law, or a model of intelligence.
It specifies a **repeatable transformation pattern** observed across competent work, independent of domain.

The pattern is invariant.
Its instantiations are not.

---

## 1. The Transformation

At the highest level, the metapattern is a transformation:

```
T : (S, I, C) → S'
```

- **S (State):** the current situation, material, or context
- **I (Intention):** the desired change or direction
- **C (Constraints):** boundaries that limit admissible transformations
- **S' (New State):** the resulting configuration after execution

This structure is agnostic to domain. It applies equally to reasoning, software, organizational work, and system design.

---

## 2. The Engine (P ↔ V)

A transformation only exists if it can be executed and corrected.

The metapattern is driven by a simple oscillatory engine:

```
Ω = P ↔ V
```

- **P — Potential / Expansion**
  - generate variants
  - explore interpretations
  - widen the search space

- **V — Validation / Contraction**
  - test against intention and constraints
  - discard invalid variants
  - select what survives

This expansion–contraction rhythm prevents two failure modes:
- unbounded divergence (noise)
- frozen convergence (premature fixation)

---

## 3. Sensitivity

When the transformation structure (Π) and the execution engine (Ω) are coupled, the system becomes sensitive:

```
Sensitivity = Π ⊗ Ω
```

Sensitivity here denotes the capacity to:
- detect a meaningful difference
- move in response to it

No assumptions are made about cognition, consciousness, or intelligence as intrinsic properties.
Sensitivity is an operational capability, not an essence.

---

## 4. The Five Phases (Φ₁–Φ₅)

Every transformation decomposes into five sequential phases.
Each phase applies the same P ↔ V rhythm locally.

| Phase | Name | Purpose |
|------:|------|---------|
| Φ₁ | INTAKE | Establish state, intention, constraints |
| Φ₂ | DECOMPOSE | Break the problem into atomic parts |
| Φ₃ | UNTANGLE | Resolve dependencies and ordering |
| Φ₄ | TRANSFORM | Execute the planned operations |
| Φ₅ | OUTPUT | Assemble results, validate, version |

### Φ₁ — Intake

- **P:** enumerate possible interpretations of the situation
- **V:** select a clear intention and explicit constraints

A transformation without Φ₁ is undefined.

---

### Φ₂ — Decompose

- **P:** identify all relevant components and sub-problems
- **V:** isolate atomic units that can be reasoned about independently

Decomposition reduces cognitive load and enables parallel work.

---

### Φ₃ — Untangle

- **P:** explore possible execution orders and dependency graphs
- **V:** select a plan that minimizes circular dependencies and deadlocks

This phase turns parts into a viable process.

---

### Φ₄ — Transform

- **P:** perform operations according to the plan
- **V:** continuously check intermediate results against constraints

Execution without validation accumulates drift.

---

### Φ₅ — Output

- **P:** consider alternative assemblies or presentations of results
- **V:** validate the outcome and increment version (V++)

Only validated outputs are retained.

---

## 5. Recursion and Resolution

Any phase may itself instantiate a full Φ₁–Φ₅ cycle.
This allows the pattern to scale across levels of granularity.

Recursion stops when validation becomes trivial.
At that point, further decomposition no longer reduces uncertainty.

---

## 6. Genotype and Phenotype

The metapattern functions as a **genotype**:
- stable
- transferable
- independent of execution context

Each concrete application is a **phenotype**:
- domain-specific
- energy-dependent
- locally optimized

The genotype travels.
The phenotype is rebuilt.

---

## 7. What This Pattern Does

The metapattern:
- standardizes transformation structure
- separates process from content
- enables auditability and replay
- supports cumulative improvement

It does not prescribe solutions.
It constrains how solutions are produced.

---

## 8. Canonical Status

This file defines the canonical form of the metapattern.

Extensions, tools, templates, and examples may evolve.
The structure described here remains invariant.
